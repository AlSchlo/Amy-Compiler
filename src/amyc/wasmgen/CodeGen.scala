package amyc
package wasmgen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        val comment = Comment(fd.toString)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          comment <:> body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {

        case Variable(name) => Comment(expr.toString) <:> GetLocal(locals(name))

        case IntLiteral(i) => Comment(expr.toString) <:> Const(i)
        case BooleanLiteral(b) => Comment(expr.toString) <:> (if b then Const(1) else Const(0))
        case StringLiteral(s) => Comment(expr.toString) <:> mkString(s)
        case UnitLiteral() => Comment(expr.toString) <:> Const(0)
        
        case Plus(lhs, rhs) => Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Add
        case Minus(lhs, rhs) => Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
        case Times(lhs, rhs) => Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
        case AmyDiv(lhs, rhs) => Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Div
        case Mod(lhs, rhs) => Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
        case LessThan(lhs, rhs) => Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
        case LessEquals(lhs, rhs) => Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
        case AmyAnd(lhs, rhs) => Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> And
        case AmyOr(lhs, rhs) => Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Or
        case Equals(lhs, rhs) => Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
        case Concat(lhs, rhs) => Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Call(concatImpl.name)

        case Not(e) => Comment(expr.toString) <:> cgExpr(e) <:> Eqz
        case Neg(e) => Comment(expr.toString) <:> Const(0) <:> cgExpr(e) <:> Sub
        case AmyCall(qname, args) =>
          table.getFunction(qname) match {
            case Some(sign) => Comment(expr.toString) <:> args.map(cgExpr(_)) <:> Call(fullName(sign.owner, qname))
            case None => table.getConstructor(qname) match {
                case Some(sign) =>
                  val freshLocal = lh.getFreshLocal()
                  val saveBoundary = GetGlobal(memoryBoundary) <:> SetLocal(freshLocal)
                  val allocate = GetGlobal(memoryBoundary) <:> adtField(args.size) <:> SetGlobal(memoryBoundary)
                  val storeIndex = GetLocal(freshLocal) <:> Const(sign.index) <:> Store
                  val argStores = args.zip(args.indices).map((e, i) => GetLocal(freshLocal) <:> adtField(i) <:> cgExpr(e) <:> Store)                
                  val popPointer = GetLocal(freshLocal)
                  Comment(expr.toString) <:> saveBoundary <:> allocate <:> storeIndex <:> argStores <:> popPointer
                case None => ctx.reporter.fatal("Unfound call name. Error in name analysis!")
              }
          }
        
        case Sequence(e1, e2) => Comment(expr.toString) <:> cgExpr(e1) <:> Drop <:> cgExpr(e2)
        case Let(df, value, body) => 
          val index = lh.getFreshLocal()
          Comment(expr.toString) <:> cgExpr(value) <:> SetLocal(index) <:> cgExpr(body)(locals + (df.name -> index), lh)
        case Ite(cond, thenn, elze) => Comment(expr.toString) <:> cgExpr(cond) <:> If_i32 <:> cgExpr(thenn) <:> Else <:> cgExpr(elze) <:> End 
        case Match(scrut, cases) =>

          // Checks if a value matches a pattern.
          // Assumes value is on top of stack (and CONSUMES it)
          // Returns the code to check the value, and a map of bindings.
          def matchAndBind(pat: Pattern): (Code, Map[Identifier, Int]) = pat match {
            
            case WildcardPattern() => (Comment(pat.toString) <:> Drop <:> Const(1), Map())

            case IdPattern(id) =>
              val idLocal = lh.getFreshLocal()
              (Comment(pat.toString) <:> SetLocal(idLocal) <:> Const(1), Map(id -> idLocal))

            case LiteralPattern(lit) => (Comment(pat.toString) <:> cgExpr(lit) <:> Eq, Map())

            case CaseClassPattern(constr, args) =>
              table.getConstructor(constr) match {
                  case Some(e) =>
                    val idLocal = lh.getFreshLocal()
                    val savePointer = SetLocal(idLocal) 
                    val indexEq = GetLocal(idLocal) <:> Load <:> Const(e.index) <:> Eq
                    val argsEqList = args.zip(args.indices).map((p, i) =>
                      val codeStart = GetLocal(idLocal) <:> adtField(i) <:> Load
                      val nextPair = matchAndBind(p)
                      ((codeStart <:> nextPair._1), nextPair._2)
                    )
                    val argsEqAll = argsEqList.foldLeft((Code(List(Const(1))), Map[Identifier, Int]()))((acc, elem) => 
                      val nextMap = acc._2 ++ elem._2
                      val nextCode = acc._1 <:> elem._1 <:> And
                      (nextCode, nextMap)
                    )
                    (Comment(pat.toString) <:> savePointer <:> indexEq <:> If_i32 <:> argsEqAll._1 <:> Else <:> Const(0) <:> End, argsEqAll._2)
                  
                  case None => ctx.reporter.fatal("Unfound match name. Error in name analysis!")
              }
            
          }

          val localId = lh.getFreshLocal()
          val saveScrut = cgExpr(scrut) <:> SetLocal(localId)
          val caseList = cases.map(mc => 
            val prevCode = GetLocal(localId)
            val codeAndMap = matchAndBind(mc.pat)
            prevCode <:> codeAndMap._1 <:> If_i32 <:> cgExpr(mc.expr)(locals ++ codeAndMap._2, lh) <:> Else 
          )
          val instructions = caseList.foldLeft(Code(Nil))((acc, elem) => acc <:> elem)
          Comment(expr.toString) <:> saveScrut <:> instructions <:> cgExpr(Error(StringLiteral("Match error!"))) <:> cases.map(_ => End)

        case Error(e) => Comment(expr.toString) <:> cgExpr(e) <:> Call("Std_printString") <:> Unreachable
      }
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
